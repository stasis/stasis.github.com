{"google":"","tagline":"/ˈstāsis/: (noun) 1. a state of equilibrium for your data; 2. a contract, us: [txn, log, cache], you: [index, data]; 3. open source database software","body":"# Stasis\r\n\r\nAn increasing range of applications requires robust support for atomic, durable and concurrent transactions. Databases provide the default solution, but force applications to interact via SQL and to forfeit control over data layout and access mechanisms. In principle, a specialized database stack could be built for each application, but such approaches have proven to be impractical. We argue there is a gap between DBMSs and file systems that limits designers of data-oriented applications.\r\n\r\nStasis is a storage framework that incorporates ideas from traditional write-ahead logging algorithms and file systems. It provides applications with flexible control over data structures, data layout, robustness and performance. Stasis enables the development of unforeseen variants on transactional storage by generalizing write-ahead logging algorithms. Instead of implementing support for each new storage system from scratch, I have extended Stasis to provide specialized storage mechanisms to a wide variety of applications. It now provides cleaner semantics than similar application-specific approaches would, with significantly less source code than would be required by multiple separate storage implementations. In addition to the conventional write-ahead logging algorithms that Stasis was designed for, it now provides support for large objects, and for log-structured indexes. A number of other extensions, such as distributed recovery algorithms and snapshot-based recovery are under development.\r\n\r\n### Support or Contact\r\nHaving trouble with Stasis? Check out the documentation at http://docs.stasis.io/ or contact support@stasis.io and we’ll help you sort it out.","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Stasis I/O"}